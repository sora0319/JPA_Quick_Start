# JPA

## 1.1

## 1.2.5 영속성 컨텍스트

-   엔터티를 영구 저장하는 환경
-   엔터티 매니저로 엔터티를 저장하거나 조회를 하면 엔터티 매니저는 영속성 컨텍스트에서 엔터티를 보관하고 관리
-   엔터티의 생명주기

    -   분리 상태
    -   관리(영속) 상태
    -   비영속 상태
    -   삭제된 상태

<br/>

-   New(비영속)

        Member member = new Member();
        member.setId();

        member는 영속성 컨텍스트의 외부에 있는 상태

-   Managed(영속)

        em.persist(member); => 영속 컨텍스트의 1차 캐쉬에 저장
        member는 영속성 컨텍스트의 내부에 있는 상태

-   Detached(분리, 준영속 상태)

        em.detach(member);
        member는 영속성 컨텍스트의 내부에서 분리된 상태

-   Removed(삭제)

        em.remove(member);
        member는 영속성 컨텍스트에서 삭제, DB에서도 삭제

<br/>

-   ## 영속성 컨텍스트의 메모리 특징

    -   영속성 컨텍스트와 식별자  
        영속성 컨텍스트는 엔터티를 식별자 값으로 구분  
        따라서, 영속 상태는 식별자 값이 반드시 필요하게 됨  
        식별자 값이 없으면 예외가 발생

        영속성 컨텍스트의 1차 캐쉬는 Map의 형태 (key value) 로 생각하면 됨
        1차 캐쉬 형태는 @id, entity 임

        member 를 관리하는 경우 영속 컨텍스트의 1차 캐쉬 모양

        |    @id    |     entity     |          snapshot          |
        | :-------: | :------------: | :------------------------: |
        | 'member1' | member1 entity | member1 entity 원본 <=> DB |
        | 'member2' | member2 entity | member2 entity 원본 <=> DB |

        => snapshot 항목은 entity 의 update 상태 유무를 판단하기 위한 것임 (변경 감지용) <br/><br/>

    -   조회  
        찾는 엔터타거 1차 캐쉬에 없으면,

        영속 엔터티의 동일성

            Member a = em.find('member1');
            Member b = em.find('member1');

        동일성 비교를 하면 결과는 항상 ture  
        => 영속성 컨텍스트는 항상 동일성을 보장

        getById() : 검색한다는 의미보다 가져온다는 의미  
        해당되는 엔터티가 없으면 예외 발생

        findById() : 검색한다는 의미  
        실제 DB에 요청해서 엔터티를 가져온다  
        영속성 컨텍스트의 1차 캐쉬에 먼저 확인 후, 엔터티가 없으면 실제 DB에 데이터가 있는지 확인함

        결과적으로 entity가 있거나, 없으면, null 이 발생함 <br/><br/>

    -   등록  
        엔터티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔터티를 저장하지 않고,내부 쿼리 저장소인 지연 SQL 저장소에 insert sql을 계속 쌓아서 저장

        트랜잭션이 커밋을 할 때 쓰기 지연 SQL 저장소에 저장된 쿼리들을 한꺼번에 데이터베이스에 전송

        이것을 쓰기 지연이라고 함 <br/><br/>

    -   수정  
        커밋하기 전까지의 모든 SQL은 쓰기 지연 SQL 저장소에 저장된 상태

        트랜잭션을 커밋하면 엔터니 매니저 내부에서 먼저 flush() 호출  
        엔터티와 snapshot 을 비교하여 변경된 엔터티를 찾음

        변경된 엔터티가 있으면 update sql 을 생성하여 쓰기 지연 SQL 저장소에 저장함

        #### JPA 의 기본 전략은 엔터티의 모든 필드를 대상으로 update를 수행

            이유 : 애플리케이션 로딩 시점에 update sql을 미리 생성해 두고 재사용이 가능할 수 있음
            데이터베이스에 동일한 SQL을 전송하면 데이터베이스는 이전에 한 번 파싱된 SQL을 재사용할 수 있게 된다

        <br/>

    -   삭제  
        삭제의 경우도 바로 삭제가 되는 것이 아니라, 쓰기 지연 SQL 저장소에 SQL 이 저장된 후 트랜잭션이 커밋해서 엔터티 매니저의 flush() 가 호출되면 실제 데이터베이스에 delete sql을 전달하게 됨

        <br/>

    -   flush()  
        영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 기능

        변경감지가 동작해서 영속성 컨텍스트에 있는 모든 엔터티를 스냅샷과 비교해서 수정이 발생된 엔터티를 찾음  
        수정된 엔터티는 update query를 만들어서 쓰기 지연 SQL 저장소에 저장

        스기 지연 SQL 저장소의 쿼리가 데이터베이스에 전송(insert, update, delete)

        영속성 컨텍스트를 flush 하는 방법

        -   entity manger의 flush() 호출  
            = 트랜잭션 커밋시 flush() 가 자동 호출
        -   JPQL 쿼리 실행시 자동을 flush() 가 호출됨
# JPA_Quick_Start
